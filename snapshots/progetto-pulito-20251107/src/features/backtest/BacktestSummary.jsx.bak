import React, { useMemo } from 'react';
import PortfolioChart from '../../components/charts/PortfolioChart';
import DrawdownChart from '../../components/charts/DrawdownChart';
import ExtremePerformanceHistogram from '../../components/analysis/ExtremePerformanceHistogram';
import { formatMoney, formatDate } from '../../utils/formatters';
import '../../styles/components.css';

/**
 * BacktestSummary - versione più fedele al legacy: grafico storico + key metrics + histogram + drawdown section
 * Layout aggiornato per riprodurre l'impaginazione ordinata del legacy:
 * - prima riga: grafico storico (sinistra) + key metrics (destra)
 * - seconda riga: histogram (sinistra) + drawdown section (destra)
 */
export default function BacktestSummary({ result }) {
  if (!result) return null;
  const summary = result.summary || {};
  const chartData = result.chart_data || result.equity_curve || result.series || [];
  const allAnnualReturns = result.all_annual_returns || result.annual_returns || result.annual_returns_data || [];

  // Key metrics row (legacy-like)
  const KeyMetricsRow = ({ summary }) => {
    const metrics = [
      { label: 'Rendimento Annuo (CAGR)', key: 'cagr_approx', color: '#66bb6a' },
      { label: 'Rendimento Totale', key: 'total_return_percentage', color: '#66bb6a' },
      { label: 'Volatilità Annua', key: 'annual_volatility', color: '#ffb300' },
      { label: 'Sharpe Ratio', key: 'sharpe_ratio', color: '#1e88e5' },
      { label: 'Valore Finale', key: 'final_value', color: '#ffffff' },
    ];
    return (
      <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
        {/* container metrics: vertical stack to mimic legacy sidebar */}
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 12 }}>
          {metrics.map(metric => (
            <div key={metric.key} style={{ background: 'linear-gradient(180deg,#171717,#141414)', padding: 12, borderRadius: 8, minWidth: 140, borderLeft: `4px solid ${metric.color}` }}>
              <div style={{ fontSize: 13, opacity: 0.85, marginBottom: 6 }}>{metric.label}</div>
              <div style={{ fontSize: 18, fontWeight: 800 }}>
                {(() => {
                  const v = summary[metric.key] ?? null;
                  if (v == null) return '—';
                  if (metric.key.includes('value')) return formatMoney(Number(v));
                  if (metric.key.includes('sharpe')) return Number(v).toFixed(2);
                  return `${Number(v).toFixed(2)}%`;
                })()}
              </div>
            </div>
          ))}
        </div>

        {/* meta small row: date range, initial investment, maybe other summary fields */}
        <div style={{ display: 'flex', gap: 12, alignItems: 'center', flexWrap: 'wrap' }}>
          <div style={{ color: '#cfcfcf', fontSize: 13 }}>
            {summary?.start_date ? `Inizio: ${formatDate(summary.start_date)}` : ''}
          </div>
          <div style={{ color: '#cfcfcf', fontSize: 13 }}>
            {summary?.end_date ? `Fine: ${formatDate(summary.end_date)}` : ''}
          </div>
          <div style={{ color: '#cfcfcf', fontSize: 13 }}>
            {summary?.initial_investment ? `Capitale Iniziale: ${formatMoney(Number(summary.initial_investment))}` : ''}
          </div>
        </div>
      </div>
    );
  };

  // DrawdownSection with recovery days calculation similar to legacy
  const DrawdownSection = ({ summary, chartData }) => {
    // compute daily drawdown and recovery days like legacy
    let drawdown = Number(summary?.max_drawdown ?? 0);
    let drawdownDate = summary?.max_drawdown_date ?? null;
    let recoveryDate = summary?.max_recovery_end_date ?? null;
    let recoveryDays = typeof summary?.max_recovery_time_days === 'number' ? Number(summary.max_recovery_time_days) : null;

    if (Array.isArray(chartData) && chartData.length > 1) {
      let peak = -Infinity;
      const daily = chartData.map(d => {
        const v = Number(d.Value ?? d.value ?? 0);
        if (v > peak) peak = v;
        const dd = (v / peak - 1) * 100;
        return { Date: d.Date, Value: v, Drawdown: dd, PeakValue: peak };
      });

      // determine trough (most negative drawdown)
      let trough = daily.reduce((acc, cur) => (cur.Drawdown < (acc?.Drawdown ?? 0) ? cur : acc), null);
      if (trough) {
        drawdownDate = trough.Date || drawdownDate;
        // find peak index before trough
        const troughIdx = daily.findIndex(d => d.Date === trough.Date);
        let peakIndex = 0;
        for (let i = troughIdx; i >= 0; i--) {
          if (daily[i].Value >= trough.PeakValue * 0.99999) { peakIndex = i; break; }
        }

        // find recovery index after trough (Drawdown >= -0.01)
        let recoveryIndex = -1; let recovered = false;
        for (let i = troughIdx; i < daily.length; i++) {
          if (daily[i].Drawdown >= -0.01) { recoveryIndex = i; recovered = true; break; }
        }

        if (recoveryIndex !== -1) {
          recoveryDate = daily[recoveryIndex].Date;
          try {
            const peakDateObj = new Date(daily[peakIndex].Date);
            const recDateObj = new Date(recoveryDate);
            const diffDays = Math.round((recDateObj - peakDateObj) / (1000 * 60 * 60 * 24));
            recoveryDays = Number.isFinite(diffDays) ? diffDays : recoveryDays;
          } catch (e) { /* ignore */ }
        } else {
          try {
            const peakDateObj = new Date(daily[peakIndex].Date);
            const lastDateObj = new Date(daily[daily.length - 1].Date);
            const diffDays = Math.round((lastDateObj - peakDateObj) / (1000 * 60 * 60 * 24));
            recoveryDays = Number.isFinite(diffDays) ? diffDays : recoveryDays;
            recoveryDate = null;
          } catch (e) { /* ignore */ }
        }

        // update drawdown value from computed series (absolute)
        const minDD = Math.min(...daily.map(d => d.Drawdown));
        drawdown = Math.abs(minDD);
      }
    }

    const drawdownFormatted = (typeof drawdown === 'number' && isFinite(drawdown)) ? `${drawdown.toFixed(2)}%` : '-';
    const recoveryFormatted = (typeof recoveryDays === 'number' && isFinite(recoveryDays)) ? `${recoveryDays} giorni` : '-';

    return (
      <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
        <div style={{ background: 'linear-gradient(180deg,#171717,#141414)', padding: 12, borderRadius: 8 }}>
          <div style={{ fontSize: 13, color: '#cfcfcf', marginBottom: 6 }}>Max Drawdown</div>
          <div style={{ fontWeight: 800, fontSize: 18, color: '#ef5350' }}>{drawdownFormatted}</div>
          <div style={{ color: '#999', marginTop: 6 }}>{drawdownDate ? `Picco: ${formatDate(drawdownDate)}` : ''}</div>
          <div style={{ color: '#999', marginTop: 6 }}>Durata recupero: <strong style={{ color: '#ffb300' }}>{recoveryFormatted}</strong></div>
          {recoveryDate ? <div style={{ color: '#999', marginTop: 6 }}>Fine recupero: {formatDate(recoveryDate)}</div> : null}
        </div>

        <div style={{ background: 'linear-gradient(180deg,#171717,#141414)', padding: 10, borderRadius: 8 }}>
          <DrawdownChart chartData={chartData} summary={summary} />
        </div>
      </div>
    );
  };

  return (
    <div className="panel summary-panel" style={{ padding: 14, marginTop: 12 }}>
      <h3 style={{ color: '#fff', margin: 0, marginBottom: 12 }}>Risultati Backtest</h3>

      {/* Top row: storico (left) + key metrics (right) */}
      <div style={{ display: 'grid', gridTemplateColumns: '2fr 1fr', gap: 18, alignItems: 'start' }}>
        <div>
          {chartData && chartData.length > 0 ? (
            <div style={{ background: 'linear-gradient(180deg,#0f0f0f,#0b0b0b)', padding: 10, borderRadius: 8 }}>
              <PortfolioChart data={result} title={`Andamento Storico`} />
            </div>
          ) : (
            <div style={{ color: '#999', padding: 12 }}>Grafico storico non disponibile</div>
          )}
        </div>

        <div>
          <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
            <KeyMetricsRow summary={summary} />
            {/* small summary box for extra info (keeps order like legacy) */}
            <div style={{ background: 'linear-gradient(180deg,#171717,#141414)', padding: 12, borderRadius: 8 }}>
              <div style={{ fontSize: 13, color: '#cfcfcf', marginBottom: 6 }}>Riepilogo</div>
              <div style={{ color: '#fff', fontWeight: 700 }}>{summary?.strategy_name ?? summary?.name ?? 'Strategia'}</div>
              <div style={{ color: '#999', marginTop: 8, fontSize: 13 }}>
                {summary?.notes ?? ''}
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Bottom row: histogram + drawdown section */}
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 380px', gap: 18, marginTop: 20 }}>
        <div>
          <div style={{ background: 'linear-gradient(180deg,#0f0f0f,#0b0b0b)', padding: 12, borderRadius: 8 }}>
            <ExtremePerformanceHistogram summary={summary} allAnnualReturns={allAnnualReturns} />
          </div>
        </div>

        <div>
          <DrawdownSection summary={summary} chartData={chartData} />
        </div>
      </div>
    </div>
  );
}